import { Maybe } from './maybe.js';
import { ResultAsync } from './resultAsync.js';
import { Unit } from './unit.js';
import { ActionOfT, AsyncActionOfT, FunctionOfT, FunctionOfTtoK, MaybeMatcher, MaybeMatcherNoReturn, None, Some } from './utilities.js';
/**
 * Represents an asynchronous value that might or might not exist
 */
export declare class MaybeAsync<TValue> {
    /**
     * Creates a new MaybeAsync from the given value
     * @param value Can be a Promise or Maybe
     * @returns MaybeAsync
     */
    static from<TValue>(maybe: Maybe<TValue>): MaybeAsync<TValue>;
    static from<TValue>(maybePromise: Promise<Maybe<TValue>>): MaybeAsync<TValue>;
    static from<TValue>(promise: Promise<Some<TValue> | None>): MaybeAsync<TValue>;
    /**
     * Creates a new MaybeAsync from the given value
     * @param value
     * @returns
     */
    static some<TValue>(value: Some<TValue>): MaybeAsync<TValue>;
    /**
     * Creates a new MaybeAsync with no value
     * @returns
     */
    static none<TValue>(): MaybeAsync<TValue>;
    get hasValue(): Promise<boolean>;
    get hasNoValue(): Promise<boolean>;
    private value;
    protected constructor(value: Promise<Maybe<TValue>>);
    /**
     * Returns the value of the MaybeAsync if it has one,
     * and the default value if there is none
     * @param defaultValue
     */
    getValueOrDefault(defaultValue: Some<TValue>): Promise<TValue>;
    /**
     * Returns the value of the MaybeAsync if it has one,
     * and returns the result of the factory function if
     * there is none
     * @param factory
     */
    getValueOrDefault(factory: FunctionOfT<Some<TValue>>): Promise<TValue>;
    /**
     * Returns the value of the MaybeAsync and throws
     * and returns a rejected Promise is there is none
     * @returns
     */
    getValueOrThrow(): Promise<Some<TValue>>;
    pipe(): MaybeAsync<TValue>;
    pipe<A>(op1: MaybeAsyncOpFn<TValue, A>): MaybeAsync<A>;
    pipe<A, B>(op1: MaybeAsyncOpFn<TValue, A>, op2: MaybeAsyncOpFn<A, B>): MaybeAsync<B>;
    pipe<A, B, C>(op1: MaybeAsyncOpFn<TValue, A>, op2: MaybeAsyncOpFn<A, B>, op3: MaybeAsyncOpFn<B, C>): MaybeAsync<C>;
    pipe<A, B, C, D>(op1: MaybeAsyncOpFn<TValue, A>, op2: MaybeAsyncOpFn<A, B>, op3: MaybeAsyncOpFn<B, C>, op4: MaybeAsyncOpFn<C, D>): MaybeAsync<D>;
    pipe<A, B, C, D, E>(op1: MaybeAsyncOpFn<TValue, A>, op2: MaybeAsyncOpFn<A, B>, op3: MaybeAsyncOpFn<B, C>, op4: MaybeAsyncOpFn<C, D>, op5: MaybeAsyncOpFn<D, E>): MaybeAsync<E>;
    pipe<A, B, C, D, E, F>(op1: MaybeAsyncOpFn<TValue, A>, op2: MaybeAsyncOpFn<A, B>, op3: MaybeAsyncOpFn<B, C>, op4: MaybeAsyncOpFn<C, D>, op5: MaybeAsyncOpFn<D, E>, op6: MaybeAsyncOpFn<E, F>): MaybeAsync<F>;
    pipe<A, B, C, D, E, F, G>(op1: MaybeAsyncOpFn<TValue, A>, op2: MaybeAsyncOpFn<A, B>, op3: MaybeAsyncOpFn<B, C>, op4: MaybeAsyncOpFn<C, D>, op5: MaybeAsyncOpFn<D, E>, op6: MaybeAsyncOpFn<E, F>, op7: MaybeAsyncOpFn<F, G>): MaybeAsync<G>;
    pipe<A, B, C, D, E, F, G, H>(op1: MaybeAsyncOpFn<TValue, A>, op2: MaybeAsyncOpFn<A, B>, op3: MaybeAsyncOpFn<B, C>, op4: MaybeAsyncOpFn<C, D>, op5: MaybeAsyncOpFn<D, E>, op6: MaybeAsyncOpFn<E, F>, op7: MaybeAsyncOpFn<F, G>, op8: MaybeAsyncOpFn<G, H>): MaybeAsync<H>;
    map<TNewValue>(projection: FunctionOfTtoK<TValue, Some<TNewValue>>): MaybeAsync<TNewValue>;
    map<TNewValue>(projection: FunctionOfTtoK<TValue, Promise<Some<TNewValue>>>): MaybeAsync<TNewValue>;
    tap(action: ActionOfT<TValue>): MaybeAsync<TValue>;
    tap(action: AsyncActionOfT<TValue>): MaybeAsync<TValue>;
    bind<TNewValue>(projection: FunctionOfTtoK<TValue, Maybe<TNewValue>>): MaybeAsync<TNewValue>;
    bind<TNewValue>(projection: FunctionOfTtoK<TValue, MaybeAsync<TNewValue>>): MaybeAsync<TNewValue>;
    match<TNewValue>(matcher: MaybeMatcher<TValue, TNewValue>): Promise<TNewValue>;
    match(matcher: MaybeMatcherNoReturn<TValue>): Promise<Unit>;
    execute(func: ActionOfT<TValue>): Promise<Unit>;
    execute(func: AsyncActionOfT<TValue>): Promise<Unit>;
    or(fallback: Some<TValue> | FunctionOfT<Some<TValue>> | Maybe<TValue> | FunctionOfT<Maybe<TValue>> | MaybeAsync<TValue> | FunctionOfT<MaybeAsync<TValue>>): MaybeAsync<TValue>;
    toResult<TError>(error: Some<TError>): ResultAsync<TValue, TError>;
    /**
     * Returns the inner Promise, wrapping Maybe.none if handleError is true
     * for a rejected Promise, otherwise rejected Promise handling is left up to the caller.
     * @param handleError
     * @returns
     */
    toPromise(handleError?: boolean): Promise<Maybe<TValue>>;
}
export type MaybeAsyncOpFn<A, B> = FunctionOfTtoK<MaybeAsync<A>, MaybeAsync<B>>;
