import { Result } from './result.js';
import { Unit } from './unit.js';
import { isDefined, isFunction, isPromise, pipeFromArray, } from './utilities.js';
/**
 * Represents and asynchronous Result that could succeed with a value or fail with an error
 */
export class ResultAsync {
    static from(value) {
        if (isPromise(value)) {
            return new ResultAsync(value.then((v) => v instanceof Result ? v : Result.success(v)));
        }
        else if (value instanceof Result) {
            return new ResultAsync(Promise.resolve(value));
        }
        throw new Error('Value must be a Promise or Result instance');
    }
    static try(promiseOrFunction, errorHandler) {
        if (isPromise(promiseOrFunction)) {
            return new ResultAsync(promiseOrFunction
                .then((value) => Result.success(value))
                .catch(unwrapHandledError(errorHandler)));
        }
        try {
            return new ResultAsync(promiseOrFunction()
                .then((value) => Result.success(value))
                .catch(unwrapHandledError(errorHandler)));
        }
        catch (error) {
            return new ResultAsync(unwrapHandledError(errorHandler)(error));
        }
    }
    static success(value) {
        const result = isDefined(value)
            ? Result.success(value)
            : Result.success(Unit.Instance);
        return new ResultAsync(Promise.resolve(result));
    }
    /**
     * Creates a new failed ResultAsync with the given error
     * @param error
     */
    static failure(error) {
        return new ResultAsync(Promise.resolve(Result.failure(error)));
    }
    constructor(value) {
        this.value = value;
    }
    /**
     * True if the Result was successful
     */
    get isSuccess() {
        return this.value.then((r) => r.isSuccess);
    }
    /**
     * True if the Result failed
     */
    get isFailure() {
        return this.value.then((r) => r.isFailure);
    }
    /**
     * Will return the inner value created from executing the Result
     * if it was successful, otherwise it will throw an Error
     * @returns the result of a successful Result
     */
    getValueOrThrow() {
        return this.value.then((r) => r.getValueOrThrow());
    }
    getValueOrDefault(defaultOrValueFactory) {
        return this.value.then((r) => isFunction(defaultOrValueFactory)
            ? r.getValueOrDefault(defaultOrValueFactory)
            : r.getValueOrDefault(defaultOrValueFactory));
    }
    /**
     * Will return the inner error value of the Result
     * if it failed, otherwise it will throw an Error
     * @returns the error of a failed Result
     */
    getErrorOrThrow() {
        return this.value.then((r) => r.getErrorOrThrow());
    }
    getErrorOrDefault(defaultOrErrorCreator) {
        return this.value.then((r) => {
            return isFunction(defaultOrErrorCreator)
                ? r.getErrorOrDefault(defaultOrErrorCreator)
                : r.getErrorOrDefault(defaultOrErrorCreator);
        });
    }
    /**
     * Checks the value of a given predicate against the Result's inner value,
     * if the Result already succeeded
     * @param predicate check against the Result's inner value
     * @param errorOrErrorCreator either an error value or a function to create an error from the Result's inner value
     * @returns a successful ResultAsync if the predicate is true, and a failed one if not
     */
    ensure(predicate, errorOrErrorCreator) {
        return new ResultAsync(this.value.then(async (result) => {
            if (result.isFailure) {
                return result;
            }
            const value = result.getValueOrThrow();
            if (predicate(value)) {
                return result;
            }
            if (!isFunction(errorOrErrorCreator)) {
                return Result.failure(errorOrErrorCreator);
            }
            return unwrapHandledError(errorOrErrorCreator)(value);
        }));
    }
    /**
     * Executes the given operator functions, creating a custom pipeline
     * @param operations ResultAsync operation functions
     * @returns
     */
    pipe(...operations) {
        return pipeFromArray(operations)(this);
    }
    map(projection) {
        return new ResultAsync(this.value.then((r) => {
            if (r.isFailure) {
                return Result.failure(r.getErrorOrThrow());
            }
            const promiseOrValue = projection(r.getValueOrThrow());
            if (isPromise(promiseOrValue)) {
                return promiseOrValue.then((v) => Result.success(v));
            }
            return Result.success(promiseOrValue);
        }));
    }
    mapError(projection) {
        return new ResultAsync(this.value.then((r) => {
            if (r.isSuccess) {
                return Result.success(r.getValueOrThrow());
            }
            const promiseOrError = projection(r.getErrorOrThrow());
            if (isPromise(promiseOrError)) {
                return promiseOrError.then((e) => Result.failure(e));
            }
            return Result.failure(promiseOrError);
        }));
    }
    mapFailure(projection) {
        return new ResultAsync(this.value.then((r) => {
            if (r.isSuccess) {
                return r;
            }
            const valueOrPromise = projection(r.getErrorOrThrow());
            if (isPromise(valueOrPromise)) {
                return valueOrPromise.then((v) => Result.success(v));
            }
            return Result.success(valueOrPromise);
        }));
    }
    bind(projection) {
        return new ResultAsync(this.value.then((r) => {
            if (r.isFailure) {
                return Result.failure(r.getErrorOrThrow());
            }
            const resultOrResultAsync = projection(r.getValueOrThrow());
            if (resultOrResultAsync instanceof Result) {
                return resultOrResultAsync;
            }
            return resultOrResultAsync.toPromise();
        }));
    }
    /**
     * Maps a failed ResultAsync to a new ResultAsync
     * @param projection
     * @returns
     */
    bindFailure(projection) {
        return new ResultAsync(this.value.then((r) => {
            if (r.isSuccess) {
                return Result.success(r.getValueOrThrow());
            }
            const resultOrResultAsync = projection();
            return resultOrResultAsync instanceof Result
                ? resultOrResultAsync
                : resultOrResultAsync.toPromise();
        }));
    }
    tap(action) {
        return new ResultAsync(this.value.then(async (originalResult) => {
            if (originalResult.isFailure) {
                return originalResult;
            }
            const voidOrPromise = action(originalResult.getValueOrThrow());
            if (isPromise(voidOrPromise)) {
                await voidOrPromise;
            }
            return originalResult;
        }));
    }
    tapIf(conditionOrPredicate, action) {
        return new ResultAsync(this.value.then((r) => {
            return isFunction(conditionOrPredicate)
                ? r.tapIf(conditionOrPredicate, action)
                : r.tapIf(conditionOrPredicate, action);
        }));
    }
    tapEither(action) {
        return new ResultAsync(this.value.then(async (originalResult) => {
            const actionResult = action();
            if (actionResult instanceof Promise) {
                await actionResult;
            }
            return originalResult;
        }));
    }
    match(matcher) {
        return this.value.then((r) => r.match(matcher));
    }
    /**
     * Maps both failed and successful ResultAsync to a new value
     * @param projection a function given the inner Result of the ResultAsync that returns a new value
     * @returns
     */
    finally(projection) {
        return this.value.then((r) => r.finally(projection));
    }
    tapFailure(action) {
        return new ResultAsync(this.value.then(async (r) => {
            if (r.isSuccess) {
                return r;
            }
            const error = r.getErrorOrThrow();
            const result = action(error);
            if (isPromise(result)) {
                await result;
            }
            return Result.failure(error);
        }));
    }
    onSuccessTry(action, errorHandler) {
        return new ResultAsync(this.value.then(async (r) => {
            if (r.isFailure) {
                return r;
            }
            const value = r.getValueOrThrow();
            try {
                const result = action(value);
                if (isPromise(result)) {
                    await result;
                }
                return Result.success(value);
            }
            catch (error) {
                return Result.failure(errorHandler(error));
            }
        }));
    }
    /**
     * Returns the inner Promise, wrapping a failed Result for a rejected Promise with the
     * given errorHandler if provided, othewise rejected Promise handling
     * is left to the caller.
     * @param errorHandler a value or Promise returning error handler that converts a rejected Promise
     *  to a failed Result.
     * @returns
     */
    toPromise(errorHandler) {
        if (!isDefined(errorHandler)) {
            return this.value;
        }
        return this.value.catch(unwrapHandledError(errorHandler));
    }
}
function unwrapHandledError(errorHandler) {
    return async (error) => {
        const handledResultOrPromise = errorHandler(error);
        if (handledResultOrPromise instanceof Promise) {
            const unwrappedResult = await handledResultOrPromise;
            return Result.failure(unwrappedResult);
        }
        return Result.failure(handledResultOrPromise);
    };
}
