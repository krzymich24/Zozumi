import { MaybeAsync } from './maybeAsync.js';
import { Result } from './result.js';
import { Unit } from './unit.js';
import { Action, ActionOfT, AsyncAction, AsyncActionOfT, FunctionOfT, FunctionOfTtoK, MaybeMatcher, MaybeMatcherNoReturn, None, PredicateOfT, Some } from './utilities.js';
/**
 * Represents a value that might not exist. Undefined and null values are always represented as Maybe.none.
 */
export declare class Maybe<TValue> {
    /**
     * Creates a new Maybe with a value
     * @param value The value of the new maybe
     * @returns
     */
    static some<TValue>(value: Some<TValue>): Maybe<TValue>;
    /**
     * Creates a new Maybe with no value
     * @returns {Maybe}
     */
    static none<TValue>(): Maybe<TValue>;
    /**
     * Creates a new Maybe. If no value is provided, it is equivalent to calling Maybe.none(), and
     * if a value is provided, it is equivalent to calling Maybe.some(val)
     * @param value The value of the new Maybe.
     * @returns {Maybe}
     */
    static from<TValue>(value: Some<TValue> | None): Maybe<TValue>;
    /**
     * Returns a Maybe containing the first value of the array,
     * and a Maybe.none if the array is empty
     * @param values
     */
    static tryFirst<TValue>(values: TValue[]): Maybe<TValue>;
    /**
     * Returns a Maybe containing the value of the first element
     * of the array matching the condition of the predicate, and
     * a Maybe.none if there are no matches
     * @param values
     * @param predicate
     */
    static tryFirst<TValue>(values: Some<TValue>[], predicate: PredicateOfT<Some<TValue>>): Maybe<TValue>;
    /**
     * Returns a Maybe containing the last value of the array,
     * and a Maybe.none if the array is empty
     * @param values
     */
    static tryLast<TValue>(values: TValue[]): Maybe<TValue>;
    /**
     * Returns a Maybe containing the value of the last element
     * of the array matching the condition of the predicate, and
     * a Maybe.none if there are no matches
     * @param values
     * @param predicate
     */
    static tryLast<TValue>(values: Some<TValue>[], predicate: PredicateOfT<Some<TValue>>): Maybe<TValue>;
    /**
     * Returns only the Maybe instances of the array that have
     * values
     * @param maybes
     */
    static choose<TValue>(maybes: Maybe<TValue>[]): TValue[];
    /**
     * Returns only the Maybe instances of the array that have values,
     * passing each value to the given projection to be transformed to a new
     * value
     * @param maybes
     * @param projection
     */
    static choose<TValue, TNewValue>(maybes: Maybe<TValue>[], projection: FunctionOfTtoK<TValue, Some<TNewValue>>): TNewValue[];
    private value;
    /**
     * Returns true if the Maybe contains a value
     */
    get hasValue(): boolean;
    /**
     * Returns true if the Maybe has no value
     */
    get hasNoValue(): boolean;
    protected constructor(value: Some<TValue> | None);
    /**
     * Returns the value of the Maybe if it has one,
     * and the default value if there is none
     * @param defaultValue
     */
    getValueOrDefault(defaultValue: Some<TValue>): TValue;
    /**
     * Returns the value of the Maybe if it has one,
     * and returns the result of the factory function if
     * there is none
     * @param factory
     */
    getValueOrDefault(factory: FunctionOfT<Some<TValue>>): TValue;
    /**
     * Returns the value of the Maybe and throws
     * and Error if there is none
     * @returns
     */
    getValueOrThrow(): Some<TValue>;
    pipe(): Maybe<TValue>;
    pipe<A>(op1: MaybeOpFnAsync<TValue, A>): MaybeAsync<A>;
    pipe<A>(op1: MaybeOpFn<TValue, A>): Maybe<A>;
    pipe<A, B>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFnAsync<A, B>): MaybeAsync<B>;
    pipe<A, B>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>): Maybe<B>;
    pipe<A, B, C>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>): Maybe<C>;
    pipe<A, B, C>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFnAsync<B, C>): Maybe<C>;
    pipe<A, B, C, D>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>): Maybe<D>;
    pipe<A, B, C, D>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFnAsync<C, D>): Maybe<D>;
    pipe<A, B, C, D, E>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFn<D, E>): Maybe<E>;
    pipe<A, B, C, D, E>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFnAsync<D, E>): Maybe<E>;
    pipe<A, B, C, D, E, F>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFn<D, E>, op6: MaybeOpFn<E, F>): Maybe<F>;
    pipe<A, B, C, D, E, F>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFn<D, E>, op6: MaybeOpFnAsync<E, F>): Maybe<F>;
    pipe<A, B, C, D, E, F, G>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFn<D, E>, op6: MaybeOpFn<E, F>, op7: MaybeOpFn<F, G>): Maybe<G>;
    pipe<A, B, C, D, E, F, G>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFn<D, E>, op6: MaybeOpFn<E, F>, op7: MaybeOpFnAsync<F, G>): Maybe<G>;
    pipe<A, B, C, D, E, F, G, H>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFn<D, E>, op6: MaybeOpFn<E, F>, op7: MaybeOpFn<F, G>, op8: MaybeOpFn<G, H>): Maybe<H>;
    pipe<A, B, C, D, E, F, G, H>(op1: MaybeOpFn<TValue, A>, op2: MaybeOpFn<A, B>, op3: MaybeOpFn<B, C>, op4: MaybeOpFn<C, D>, op5: MaybeOpFn<D, E>, op6: MaybeOpFn<E, F>, op7: MaybeOpFn<F, G>, op8: MaybeOpFnAsync<G, H>): Maybe<H>;
    /**
     * Converts the value of the Maybe, if there is one, to a new value
     * as defined by the provided projection function
     * @param projection
     * @returns
     */
    map<TNewValue>(projection: FunctionOfTtoK<TValue, Some<TNewValue>>): Maybe<TNewValue>;
    /**
     * Converts the value of the Maybe, if there is one, to a new value
     * as defined by the provided projection, wrapping the asynchronous result in a MaybeAsync
     * @param projection
     * @returns
     */
    mapAsync<TNewValue>(projection: FunctionOfTtoK<TValue, Promise<Some<TNewValue>>>): MaybeAsync<TNewValue>;
    /**
     * Executes the given action if the Maybe has a value
     * @param action
     * @returns
     */
    tap(action: ActionOfT<TValue>): Maybe<TValue>;
    /**
     * Executes the given asynchronous action if the Maybe has a
     * value and retursn a new MaybeAsync
     * @param asyncAction
     * @returns
     */
    tapAsync(asyncAction: FunctionOfTtoK<TValue, Promise<void>>): MaybeAsync<TValue>;
    /**
     * Executes an action if the Maybe has no value
     * @param action
     */
    tapNone(action: Action): Maybe<TValue>;
    /**
     * Executes an action if the Maybe has no value
     * @param action
     */
    tapNoneAsync(action: AsyncAction): MaybeAsync<TValue>;
    /**
     * Converts the value of the Maybe, if it has one, to a new Maybe
     * @param projection
     * @returns
     */
    bind<TNewValue>(projection: FunctionOfTtoK<TValue, Maybe<Some<TNewValue>>>): Maybe<TNewValue>;
    /**
     * Converts the value of the Maybe, if it has one, to a new
     * MaybeAsync
     * @param projection
     * @returns
     */
    bindAsync<TNewValue>(projection: FunctionOfTtoK<TValue, MaybeAsync<Some<TNewValue>>>): MaybeAsync<TNewValue>;
    /**
     * Maps the value of the Maybe, if it has one, using the given projection some function,
     * and the none function otherwise
     * @param projection
     */
    match<TNewValue>(projection: MaybeMatcher<TValue, TNewValue>): TNewValue;
    /**
     * Executes the some function of the given matcher if the Maybe has a value,
     * and the none function if there is no value
     * @param matcher
     * @returns
     */
    match(matcher: MaybeMatcherNoReturn<TValue>): Unit;
    /**
     * Executes the given action if the Maybe has a value
     * @param action
     */
    execute(action: ActionOfT<TValue>): Unit;
    /**
     * Executes the given async action if the Maybe has a value
     * @param action A void Promise returning function
     * @returns A Promise containing Unit
     */
    executeAsync(action: AsyncActionOfT<TValue>): Promise<Unit>;
    /**
     * Returns the Maybe if it has a value, otherwise it returns
     * the fallbackValue returned in a Maybe
     * @param fallbackValue
     */
    or(fallbackValue: Some<TValue>): Maybe<TValue>;
    /**
     * Returns the Maybe if it has a value, otherwise it returns the fallbackMaybe
     * @param fallbackMaybe
     */
    or(fallbackMaybe: Maybe<TValue>): Maybe<TValue>;
    /**
     * Returns the Maybe if it has a value, otherwise executes and
     * returns the value of the fallbackFactory wrapped in a Maybe
     * @param fallbackfactory
     */
    or(fallbackfactory: FunctionOfT<Some<TValue>>): Maybe<TValue>;
    /**
     * Returns the Maybe if it has a value, otherwise executes the fallbackMaybeFactory
     * and returns its result
     * @param fallbackMaybefactory
     */
    or(fallbackMaybefactory: FunctionOfT<Maybe<TValue>>): Maybe<TValue>;
    /**
     * Returns the Maybe, wrapped in a MaybeAsync, if it has a value, otherwise
     * returns the fallback MaybeAsync
     * @param fallbackPromise
     * @returns
     */
    orAsync(fallbackMaybeAsync: MaybeAsync<TValue>): MaybeAsync<TValue>;
    /**
     * Returns the Maybe, wrapped in a MaybeAsync, if it has a value, otherwise
     * returns executes the fallbackPromiseFactory and returns its value wrapped in a MaybeAsync
     * @param fallbackPromise
     * @returns
     */
    orAsync(fallbackPromiseFactory: FunctionOfT<Promise<Some<TValue>>>): MaybeAsync<TValue>;
    /**
     * Returns the Maybe, wrapped in a MaybeAsync, if it has a value, otherwise
     * returns the fallbackPromise, wrapped in a MaybeAsync
     * @param fallbackPromise
     */
    orAsync(fallbackPromise: Promise<Some<TValue>>): MaybeAsync<TValue>;
    /**
     * Converts the Maybe into a Result. The Result is successful if there is a value
     * and a failure, with the given error, if there is not
     * @param error
     * @returns
     */
    toResult<TError>(error: Some<TError>): Result<TValue, TError>;
    /**
     * Returns the string representation of the Maybe (either some or none)
     * @returns
     */
    toString(): string;
    /**
     * Returns true if the Maybes both have values and the values are strictly equal
     * @param maybe
     * @returns
     */
    equals(maybe: Maybe<TValue>): boolean;
}
export type MaybeOpFn<A, B> = FunctionOfTtoK<Maybe<A>, Maybe<B>>;
export type MaybeOpFnAsync<A, B> = FunctionOfTtoK<Maybe<A>, MaybeAsync<B>>;
